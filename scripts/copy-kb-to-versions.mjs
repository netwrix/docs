#!/usr/bin/env node

/**
 * Copy KB content into versioned product docs folders
 * Solution 2 - Approach C: Build Script
 *
 * Features:
 * - Copies KB articles from central location to versioned docs folders
 * - Rewrites absolute KB links to relative paths during copy
 * - Removes .md extensions from links (Docusaurus best practice)
 * - Generates _category_.json files for proper category labeling
 * - Preserves external links and images unchanged
 * - Lockfile management to prevent concurrent runs
 * - Comprehensive validation and error handling
 *
 * Usage:
 *   node scripts/copy-kb-to-versions.js          # Copy all configured products/versions
 *   node scripts/copy-kb-to-versions.js --dry    # Preview without copying
 *   node scripts/copy-kb-to-versions.js --clean  # Remove copied KB folders
 *
 * Environment variables:
 *   COPY_KB_PRODUCTS=accessanalyzer              # Filter by product
 *   COPY_KB_VERSIONS=12.0,11.6                   # Filter by versions
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { PRODUCTS } from '../src/config/products.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ============================================================================
// Global Constants
// ============================================================================

const PROJECT_ROOT = path.resolve(__dirname, '..');
const LOCKFILE = path.join(PROJECT_ROOT, '.kb-copy.lock');
const ASSET_DIRS = ['0-images', 'images', 'assets', 'media'];

// ============================================================================
// Product Migration Control
// ============================================================================

/**
 * Products that have been migrated to use the new autogenerated KB sidebar.
 *
 * For products in this list:
 * - KB content will be copied to versioned docs folders
 * - Sidebars use autogenerated structure (no generateKBSidebar() call)
 *
 * For products NOT in this list:
 * - KB content will NOT be copied (script skips them)
 * - Sidebars continue using generateKBSidebar() (old method)
 *
 * Add products to this list as their Phase 2 migration PR is merged.
 */
const MIGRATED_PRODUCTS = [
  // Add product IDs here as they complete migration
  // Example: 'auditor', 'privilegesecure', 'threatprevention'
  '1secure', // Migrated - uses autogenerated sidebar
  'accessanalyzer', // Already migrated - uses autogenerated sidebar
  'accessinformationcenter', // Migrated - uses autogenerated sidebar
  'activitymonitor', // Migrating - sidebar to be updated
  'changetracker', // Migrated - uses autogenerated sidebar
  'dataclassification', // Migrated - uses autogenerated sidebar
  'directorymanager', // Migrating - sidebar to be updated
  'endpointpolicymanager', // Migrated - uses autogenerated sidebar
  'endpointprotector', // Migrated - uses autogenerated sidebar
  'passwordpolicyenforcer', // Migrated - uses autogenerated sidebar
  'passwordreset', // Migrated - uses autogenerated sidebar
  'privilegesecure', // Migrated - uses autogenerated sidebar
  'privilegesecurediscovery', // Migrated - uses autogenerated sidebar
  'recoveryforactivedirectory', // Migrated - uses autogenerated sidebar
  'threatmanager', // Migrated - uses autogenerated sidebar
  'threatprevention', // Migrated - scripts page restructured, uses autogenerated sidebar
];

// Build CONFIG dynamically from PRODUCTS
function buildConfig() {
  const config = {};

  PRODUCTS.forEach(product => {
    // Validate required fields
    if (!product.id || typeof product.id !== 'string') {
      throw new Error(`Product missing required field 'id' or id is not a string: ${JSON.stringify(product)}`);
    }
    if (!Array.isArray(product.versions)) {
      throw new Error(`Product '${product.id}' missing required array field 'versions'`);
    }

    const productId = product.id;
    const versions = product.versions.map(v => {
      if (!v.version || typeof v.version !== 'string') {
        throw new Error(`Product '${productId}' has version entry missing 'version' field: ${JSON.stringify(v)}`);
      }
      return v.version;
    });

    // Special handling: KB folder name mapping (for legacy naming)
    const kbFolderName = productId === 'recoveryforactivedirectory' ? 'recoveryad' : productId;

    // Special handling: Unversioned products (version: 'current')
    // For these products, copy KB to root level instead of /current/ folder
    const hasCurrentVersion = versions.includes('current');
    const destinationPattern = hasCurrentVersion
      ? `docs/${productId}/kb`
      : `docs/${productId}/{version}/kb`;

    config[productId] = {
      versions: versions,
      source: `docs/kb/${kbFolderName}`,
      destinationPattern: destinationPattern
    };
  });

  return config;
}

const CONFIG = buildConfig();

// ============================================================================
// Lockfile Management
// ============================================================================

function acquireLock(isDryRun) {
  if (isDryRun) return; // Skip locking in dry-run mode

  const tenMinutes = 10 * 60 * 1000;

  // Try at most twice: initial attempt + one retry after stale deletion
  for (let attempt = 0; attempt < 2; attempt++) {
    const now = Date.now();

    // 1) Attempt atomic create (no pre-checks)
    try {
      const fd = fs.openSync(
        LOCKFILE,
        fs.constants.O_CREAT | fs.constants.O_EXCL | fs.constants.O_WRONLY,
        0o600
      );

      try {
        fs.writeFileSync(fd, JSON.stringify({ timestamp: now }), 'utf8');
      } finally {
        fs.closeSync(fd);
      }

      return; // Lock acquired
    } catch (err) {
      if (err.code !== 'EEXIST') {
        throw new Error(`Cannot create lock file: ${err.message}`);
      }
    }

    // 2) Lock exists: determine staleness using a file descriptor (avoid statSync(path))
    let readFd;
    try {
      readFd = fs.openSync(LOCKFILE, fs.constants.O_RDONLY);
    } catch (err) {
      // Race: lock disappeared between EEXIST and open; retry loop
      continue;
    }

    let lockAge;
    try {
      const stats = fs.fstatSync(readFd);
      lockAge = now - stats.mtimeMs;
    } finally {
      fs.closeSync(readFd);
    }

    if (lockAge <= tenMinutes) {
      throw new Error('KB copy script is already running. If this is incorrect, delete .kb-copy.lock');
    }

    // 3) Stale lock: remove and retry once
    console.log('âš ï¸  Removing stale lock file');
    try {
      fs.unlinkSync(LOCKFILE);
    } catch (err) {
      throw new Error(`Cannot remove stale lock file: ${err.message}`);
    }
  }

  // If we get here, another process is racing us
  throw new Error('KB copy script is already running. If this is incorrect, delete .kb-copy.lock');
}

function releaseLock(isDryRun) {
  if (isDryRun) return;
  if (fs.existsSync(LOCKFILE)) {
    try {
      fs.unlinkSync(LOCKFILE);
    } catch (err) {
      console.warn(`âš ï¸  Warning: Could not remove lock file: ${err.message}`);
    }
  }
}

// ============================================================================
// Validation Functions
// ============================================================================

function validateVersionFormat(version) {
  // Allow common version formats: X.Y, X.Y.Z, "current", "saas", etc.
  // Just ensure it's a non-empty string with valid path characters
  if (!version || typeof version !== 'string' || version.trim() === '') {
    throw new Error(`Invalid version: empty or not a string`);
  }

  // Check for path traversal attempts
  if (version.includes('..') || version.includes('/') || version.includes('\\')) {
    throw new Error(`Invalid version format: ${version}. Contains path traversal characters`);
  }
}

function validateDestinationPath(destPath) {
  // Destination must be relative
  if (path.isAbsolute(destPath)) {
    throw new Error(`Destination path must be relative: ${destPath}`);
  }

  // Resolve and check it stays under PROJECT_ROOT
  const abs = path.resolve(PROJECT_ROOT, destPath);
  const rel = path.relative(PROJECT_ROOT, abs);

  // Defensive: block destPath that resolves exactly to the repo root
  if (rel === '') {
    throw new Error(`Destination cannot be project root: ${destPath}`);
  }

  // Reject if escapes project root
  if (rel === '..' || rel.startsWith('..' + path.sep) || path.isAbsolute(rel)) {
    throw new Error(`Path traversal detected: ${destPath} resolves outside project root`);
  }
}

function validateEnvironment(filterProducts, filterVersions, CONFIG) {
  // Validate COPY_KB_PRODUCTS
  if (filterProducts) {
    const configKeys = Object.keys(CONFIG);
    for (const product of filterProducts) {
      if (!configKeys.includes(product)) {
        throw new Error(`Invalid product: ${product}. Available: ${configKeys.join(', ')}`);
      }
    }
  }

  // Validate COPY_KB_VERSIONS
  if (filterVersions) {
    for (const version of filterVersions) {
      validateVersionFormat(version);
    }

    // Check versions exist in selected products
    const selectedProducts = filterProducts || Object.keys(CONFIG);
    for (const product of selectedProducts) {
      const availableVersions = CONFIG[product].versions;
      for (const version of filterVersions) {
        if (!availableVersions.includes(version)) {
          throw new Error(`Version ${version} not found in ${product}. Available: ${availableVersions.join(', ')}`);
        }
      }
    }
  }
}

function validateConfig(CONFIG) {
  for (const [product, productConfig] of Object.entries(CONFIG)) {
    if (!productConfig || typeof productConfig !== 'object') {
      throw new Error(`Invalid config for product ${product}: expected object`);
    }

    if (!Array.isArray(productConfig.versions)) {
      throw new Error(`Invalid config for product ${product}: versions must be an array`);
    }

    if (typeof productConfig.source !== 'string') {
      throw new Error(`Invalid config for product ${product}: source must be a string`);
    }

    if (typeof productConfig.destinationPattern !== 'string') {
      throw new Error(`Invalid config for product ${product}: destinationPattern must be a string`);
    }

    // Validate source path stays under repo root
    validateDestinationPath(productConfig.source);

    // Validate destination pattern stays under repo root (sample substitution)
    const testDest = productConfig.destinationPattern.replace('{version}', '1.0');
    validateDestinationPath(testDest);
  }
}

// ============================================================================
// Link Rewriting (Dynamic Product)
// ============================================================================

function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rewriteKbLinks(content, sourceFilePath, kbSourceRoot, productName) {
  // Dynamic regex based on product name
  const escapedProduct = escapeRegExp(productName);
  const kbLinkRegex = new RegExp(
    `\\[([^\\]]+)\\]\\(\\/docs\\/kb\\/${escapedProduct}\\/([^)#?]+?)(?:\\.md)?([#?][^)]*)?\\)`,
    'g'
  );

  return content.replace(kbLinkRegex, (match, linkText, targetPath, suffix = '') => {
    // Use absolute paths anchored to PROJECT_ROOT
    const absoluteSourcePath = path.isAbsolute(sourceFilePath)
      ? sourceFilePath
      : path.resolve(PROJECT_ROOT, sourceFilePath);

    const absoluteKbRoot = path.isAbsolute(kbSourceRoot)
      ? kbSourceRoot
      : path.resolve(PROJECT_ROOT, kbSourceRoot);

    const absoluteTargetPath = path.resolve(absoluteKbRoot, targetPath);

    const sourceDir = path.dirname(absoluteSourcePath);
    let relativePath = path.relative(sourceDir, absoluteTargetPath);

    // Remove .md extension
    relativePath = relativePath.replace(/\.md$/, '');

    // Normalize path separators
    relativePath = relativePath.replace(/\\/g, '/');

    // Add ./ prefix for same-directory links
    if (!relativePath.startsWith('../') && !relativePath.startsWith('./')) {
      relativePath = './' + relativePath;
    }

    return `[${linkText}](${relativePath}${suffix})`;
  });
}

function rewriteAndCopyMarkdownFile(srcPath, destPath, kbSourceRoot, productName, errorCount) {
  try {
    const content = fs.readFileSync(srcPath, 'utf8');
    const transformedContent = rewriteKbLinks(content, srcPath, kbSourceRoot, productName);
    fs.writeFileSync(destPath, transformedContent, 'utf8');
    return true;
  } catch (err) {
    console.log(`     âš ï¸  Failed to copy ${path.basename(srcPath)}: ${err.message}`);
    errorCount.count++;
    return false;
  }
}

// ============================================================================
// Category File Generation (Title Case with Acronym Support)
// ============================================================================

// Memoization cache for markdown file detection
const markdownCache = new Map();

function hasMarkdownFiles(dirPath) {
  if (markdownCache.has(dirPath)) {
    return markdownCache.get(dirPath);
  }

  let result = false;

  try {
    const entries = fs.readdirSync(dirPath, { withFileTypes: true });

    for (const entry of entries) {
      if (entry.isFile() && (entry.name.endsWith('.md') || entry.name.endsWith('.mdx'))) {
        result = true;
        break;
      }

      // Recursively check subdirectories
      if (entry.isDirectory() && !entry.name.startsWith('.')) {
        const subPath = path.join(dirPath, entry.name);
        if (hasMarkdownFiles(subPath)) {
          result = true;
          break;
        }
      }
    }
  } catch (error) {
    result = false;
  }

  markdownCache.set(dirPath, result);
  return result;
}

function toTitleCase(str) {
  const acronyms = ['AD', 'API', 'ID', 'SQL', 'SSL', 'TLS', 'MFA', 'SSO', 'RDS', 'UX', 'DPI'];

  return str
    .split('-')
    .map(word => {
      const upper = word.toUpperCase();
      if (acronyms.includes(upper)) {
        return upper;
      }
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
}

function generateCategoryFile(destPath, folderName) {
  // Skip hidden and underscore directories
  if (folderName.startsWith('.') || folderName.startsWith('_')) {
    return null;
  }

  // Skip asset directories
  if (ASSET_DIRS.includes(folderName.toLowerCase())) {
    return null;
  }

  const categoryPath = path.join(destPath, '_category_.json');

  // Only generate if directory contains markdown files (recursive check)
  if (!hasMarkdownFiles(destPath)) {
    return null;
  }

  const label = toTitleCase(folderName);

  try {
    const categoryConfig = {
      label: label,
      collapsed: true,
      collapsible: true,
      link: {
        type: 'generated-index',
        description: `Knowledge base articles related to ${label.toLowerCase()}.`
      }
    };

    // Use 'wx' flag to write only if file doesn't exist (atomic operation)
    // This prevents race conditions between checking and writing
    fs.writeFileSync(categoryPath, JSON.stringify(categoryConfig, null, 2) + '\n', {
      encoding: 'utf8',
      flag: 'wx'
    });
    return true; // Created successfully
  } catch (err) {
    // File already exists (EEXIST) - skip without warning
    if (err.code === 'EEXIST') {
      return null;
    }
    // Other errors - log and report failure
    console.log(`     âš ï¸  Failed to generate category file for ${folderName}: ${err.message}`);
    return false; // Failed
  }
}

// ============================================================================
// Copy Logic with Success Tracking
// ============================================================================

function copyDirectorySync(src, dest, kbSourceRoot, productName, errorCount) {
  let filesCount = 0;
  let categoriesCount = 0;

  // Create destination directory (fatal if fails)
  try {
    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest, { recursive: true });
    }
  } catch (err) {
    throw new Error(`Fatal: Cannot create directory ${dest}: ${err.message}`);
  }

  // Read source directory (fatal if fails)
  let entries;
  try {
    entries = fs.readdirSync(src, { withFileTypes: true });
  } catch (err) {
    throw new Error(`Fatal: Cannot read directory ${src}: ${err.message}`);
  }

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      // Skip hidden directories only (not underscore)
      if (entry.name.startsWith('.')) {
        continue;
      }

      // Recursively copy subdirectory (fatal errors throw up to per-version handler)
      const subCounts = copyDirectorySync(srcPath, destPath, kbSourceRoot, productName, errorCount);
      filesCount += subCounts.filesCount;
      categoriesCount += subCounts.categoriesCount;

      // Generate category file (rules applied inside function)
      const categoryResult = generateCategoryFile(destPath, entry.name);
      if (categoryResult === true) {
        categoriesCount++;
      } else if (categoryResult === false) {
        errorCount.count++;
      }
      // null = skipped, ignore
    } else {
      // Copy files (non-fatal failures, log and continue)
      if (entry.name.endsWith('.md')) {
        if (rewriteAndCopyMarkdownFile(srcPath, destPath, kbSourceRoot, productName, errorCount)) {
          filesCount++;
        }
      } else {
        try {
          fs.copyFileSync(srcPath, destPath);
          filesCount++;
        } catch (err) {
          console.log(`     âš ï¸  Failed to copy ${entry.name}: ${err.message}`);
          errorCount.count++;
        }
      }
    }
  }

  return { filesCount, categoriesCount };
}

// ============================================================================
// Remove Directory
// ============================================================================

function removeDirectorySync(dir) {
  if (!fs.existsSync(dir)) {
    return true; // Nothing to remove, success
  }

  try {
    // Prefer fs.rmSync if available (Node 14.14+)
    if (fs.rmSync) {
      fs.rmSync(dir, { recursive: true, force: true });
      return true;
    }

    // Fallback: manual recursive removal
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        const success = removeDirectorySync(fullPath);
        if (!success) return false;
      } else {
        fs.unlinkSync(fullPath);
      }
    }

    fs.rmdirSync(dir);
    return true;
  } catch (err) {
    console.log(`     âš ï¸  Failed to remove directory ${dir}: ${err.message}`);
    return false;
  }
}

// ============================================================================
// Main Logic
// ============================================================================

function main() {
  const args = process.argv.slice(2);
  const isDryRun = args.includes('--dry');
  const isClean = args.includes('--clean');

  let totalFileErrors = 0;
  let totalVersionErrors = 0;
  let totalSuccess = 0;

  try {
    // Acquire lock
    acquireLock(isDryRun);

    // Read environment filters (CLI flags override env vars)
    let filterProducts = process.env.COPY_KB_PRODUCTS
      ? process.env.COPY_KB_PRODUCTS.split(',').map(p => p.trim()).filter(Boolean)
      : null;

    let filterVersions = process.env.COPY_KB_VERSIONS
      ? process.env.COPY_KB_VERSIONS.split(',').map(v => v.trim()).filter(Boolean)
      : null;

    // CLI flags override environment variables
    args.forEach(arg => {
      if (arg.startsWith('--products=')) {
        filterProducts = arg.split('=')[1].split(',').map(p => p.trim()).filter(Boolean);
      } else if (arg.startsWith('--versions=')) {
        filterVersions = arg.split('=')[1].split(',').map(v => v.trim()).filter(Boolean);
      }
    });

    // Validate environment
    validateEnvironment(filterProducts, filterVersions, CONFIG);
    validateConfig(CONFIG);

    console.log('='.repeat(60));
    console.log('KB Copy Script - Solution 2 (Approach C)');
    console.log('='.repeat(60));

    if (isDryRun) {
      console.log('ðŸ” DRY RUN MODE - No files will be modified');
    }

    if (isClean) {
      console.log('ðŸ§¹ CLEAN MODE - Will remove destinations before copy');
    }

    if (filterProducts) {
      console.log(`ðŸ“¦ Filtering products: ${filterProducts.join(', ')}`);
    }

    if (filterVersions) {
      console.log(`ðŸ“Œ Filtering versions: ${filterVersions.join(', ')}`);
    }

    console.log('');

    // Process each product
    for (const [product, config] of Object.entries(CONFIG)) {
      // Skip if filtered out
      if (filterProducts && !filterProducts.includes(product)) {
        continue;
      }

      // Skip products that haven't been migrated yet
      // If MIGRATED_PRODUCTS is empty, skip all products (nothing migrated yet)
      // If MIGRATED_PRODUCTS has items, only process products in the list
      if (MIGRATED_PRODUCTS.length === 0 || !MIGRATED_PRODUCTS.includes(product)) {
        console.log(`\nâ­ï¸  Skipping ${product} (not yet migrated)`);
        continue;
      }

      console.log(`\nðŸ“š Product: ${product}`);
      console.log('-'.repeat(60));

      // Check if source exists
      if (!fs.existsSync(config.source)) {
        console.log(`âš ï¸  Source not found: ${config.source}`);
        totalVersionErrors++;
        continue;
      }

      // Process each version (isolated)
      for (const version of config.versions) {
        // Skip if filtered out
        if (filterVersions && !filterVersions.includes(version)) {
          continue;
        }

        try {
          // Validate version format
          validateVersionFormat(version);

          const destination = config.destinationPattern.replace('{version}', version);

          // Validate destination path
          validateDestinationPath(destination);

          console.log(`\n  ðŸ“– Version: ${version}`);
          console.log(`     Source: ${config.source}`);
          console.log(`     Dest:   ${destination}`);

          // If --clean is set, remove destination first
          if (isClean && fs.existsSync(destination)) {
            if (!isDryRun) {
              const removeSuccess = removeDirectorySync(destination);
              if (removeSuccess) {
                console.log(`     ðŸ—‘ï¸  Removed old KB folder`);
              } else {
                throw new Error('Failed to remove old KB folder');
              }
            } else {
              console.log(`     ðŸ” [dry-run] Would remove old KB folder`);
            }
          }

          // Copy KB content (always happens, regardless of --clean)
          if (!isDryRun) {
            const errorCount = { count: 0 };
            const result = copyDirectorySync(config.source, destination, config.source, product, errorCount);

            if (errorCount.count > 0) {
              console.log(`     âš ï¸  Copied with ${errorCount.count} file errors`);
              totalFileErrors += errorCount.count;
              totalSuccess++; // Version partially succeeded
            } else {
              console.log(`     âœ… Copied ${result.filesCount} files, ${result.categoriesCount} categories`);
              totalSuccess++;
            }
          } else {
            console.log(`     ðŸ” [dry-run] Would copy KB content`);
            // Don't count dry-run as success
          }
        } catch (err) {
          // Per-version error isolation
          console.log(`     âŒ Error: ${err.message}`);
          totalVersionErrors++;
          // Continue to next version
        }
      }
    }

    // Generate allowlist
    const allowlist = {};
    const productsToProcess = filterProducts || Object.keys(CONFIG);

    for (const productKey of productsToProcess) {
      const productConfig = CONFIG[productKey];
      if (!productConfig) continue;

      const versionsToProcess = filterVersions
        ? filterVersions.filter(v => productConfig.versions.includes(v))
        : productConfig.versions;

      for (const version of versionsToProcess) {
        const destination = productConfig.destinationPattern.replace('{version}', version);
        const kbDestination = path.resolve(PROJECT_ROOT, destination);

        // Only include if destination exists AND contains markdown files
        if (fs.existsSync(kbDestination) && hasMarkdownFiles(kbDestination)) {
          if (!allowlist[productKey]) {
            allowlist[productKey] = [];
          }
          if (!allowlist[productKey].includes(version)) {
            allowlist[productKey].push(version);
          }
        }
      }
    }

    // Sort products and versions for deterministic output
    const sortedAllowlist = {};
    Object.keys(allowlist).sort().forEach(key => {
      sortedAllowlist[key] = allowlist[key].sort();
    });

    const allowlistPath = path.join(PROJECT_ROOT, 'kb_allowlist.json');
    const allowlistContent = JSON.stringify(sortedAllowlist, null, 2) + '\n';

    if (isDryRun) {
      console.log('\n' + '='.repeat(60));
      console.log('ðŸ” [dry-run] Would generate kb_allowlist.json');
      console.log('Note: In dry-run mode, allowlist is computed from current filesystem state.');
      console.log('='.repeat(60));
      console.log(allowlistContent);
    } else {
      fs.writeFileSync(allowlistPath, allowlistContent, 'utf8');
      console.log('\n' + '='.repeat(60));
      console.log(`âœ… Generated: ${allowlistPath}`);
      console.log('='.repeat(60));
    }

    console.log('\n' + '='.repeat(60));
    if (isDryRun) {
      console.log('ðŸ” Dry-run complete');
      console.log('Note: No files were modified. Re-run without --dry to apply changes.');
    } else {
      console.log('âœ… Copy complete');
      console.log(`Total: ${totalSuccess} successful, ${totalFileErrors} file errors, ${totalVersionErrors} version errors`);
    }
    console.log('='.repeat(60));

  } catch (err) {
    console.error(`\nâŒ Fatal error: ${err.message}`);
    totalVersionErrors++;
  } finally {
    // Always release lock
    releaseLock(isDryRun);
  }

  // Single exit point
  // Exit with success if ANY products copied successfully
  // Only fail if there were no successes at all
  if (totalSuccess === 0 && (totalFileErrors > 0 || totalVersionErrors > 0)) {
    process.exit(1);
  }
  process.exit(0);
}

// Run
main();
